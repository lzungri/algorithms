Qué ocurre al ejecutar fopen()?
-------------------------------

Con el objeto de terminar con la presentación que hicimos el otro día en la clase (cortada por problemas técnicos, por no decir falta de batería) quiero plantearles el siguiente ejercicio que pretende mostrarles a nivel práctico la relación entre las funciones de la biblioteca estándar (libc) y las llamadas al sistema.

1- Creen un archivo llamado open_syscall.c con el siguiente programa:
	#include <stdio.h>
	void main(void) {
		fopen("open_syscall.c", "r");
	}

2- Compilarlo de la siguiente manera:
	gcc -g -static open_syscall.c -o open_syscall

3- Debuggear el programa con gdb (en próximas clases vamos a usar uno más amigable):
	gdb ./open_syscall

4- Una vez dentro del debugger hacer lo siguiente:
	1. Insertar un breakpoint en la función open():
		break open
	2. Indicar al gdb que imprima, cada vez que alcance un breakpoint, las próximas 10 instrucciones a partir del instruction pointer:
		display/10i $rip
		Si la arquitectura es de 32 bits, reemplazar $rip por $eip
	2. Ejecutar el programa:
		run
	3. El breakpoint debería haber sido alcanzado, lo cual nos indica que cuando se invoca a la función fopen() ésta termina llamando a open() (también en la libc). Recuerden que todavía estamos en modo usuario.
	Lo que ven es el desensamblado de la función open(). Sí, no se entiende nada, hagan un esfuerzo.
	La función open(), tal como habíamos visto, es un envoltorio/wrapper/"mamushka" de la llamada al sistema.
	4- A partir de ahora vamos a ejecutar instrucción por instrucción hasta llegar a la que finalmente dispara la llamada al sistema.
	Recuerden que las dos formas más populares de realizar una llamada eran: Mediante la instrucción SYSCALL/SYSENTER o mediante interrupciones (en el caso de Linux se usa la INT 0x80). El mecanismo que se use dependerá del procesador que tengan.
	Entonces ahora sí, ejecuten:
		stepi
	Tantas veces como sea necesario hasta que vean la instrucción SYSCALL o INT 0x80.
	5- Se está a punto de invocar al kernel. Cómo sabe el kernel qué función ejecutar? Esto se indica en el registro rax (o eax en 32 bits):
		info registers
	6- Si buscan el valor de rax en el archivo:
		/usr/include/x86_64-linux-gnu/asm/unistd_64.h (Si su sistema es de 64 bits)
		/usr/include/i386-linux-gnu/asm/unistd_32.h (Si su sistema es de 32 bits)
	Van a corroborar que se trata de la función del kernel sys_open.

Entonces, qué ocurre al ejecutar fopen()?:
Se llama a open() de la libc, la cual dispara la llamada al sistema que hace que se termina ejecutando la función sys_open del kernel. Esto último en modo kernel, por supuesto.


Leer:
	- http://www.jbox.dk/sanos/source/sys/krnl/syscall.c.html#:2597
